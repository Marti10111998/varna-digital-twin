<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Varna Digital Twin â€” Spectral UHI (Legend Top-Right)</title>

  <!-- UI / 3D -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/cesium@1.116/Build/Cesium/Cesium.js"></script>
  <link href="https://unpkg.com/cesium@1.116/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />

  <!-- Charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>

  <style>
    /* === Compact UI overrides === */
    html { font-size: 14px; }

    #controlPanel, #pollutionPanel, #pollutionChartPanel, #ictPanel {
      padding: 12px !important;
      border-radius: 10px !important;
      line-height: 1.25;
    }
    #controlPanel        { width: 16rem !important; }
    #pollutionPanel      { width: 13rem !important; }
    #pollutionChartPanel { width: 760px !important; }
    #ictPanel            { width: 440px !important; }

    .drag-handle { font-size: 10px !important; padding: 2px 4px !important; }
    #controlPanel .text-lg,
    #pollutionChartPanel .text-lg,
    #ictPanel .text-lg { font-size: 1rem !important; }

    #controlPanel .font-medium { font-weight: 600; font-size: .9rem !important; }
    #controlPanel .text-sm     { font-size: .8rem !important; }
    #controlPanel .text-xs     { font-size: .7rem !important; }

    #tooltip { font-size: 12px; padding: 4px 6px; }

    .uhiLegendPanel{
      padding: 8px 10px !important;
      border-radius: 10px !important;
      font-size: 11px !important;
      width: 160px !important;
    }
    .uhiLegendPanel .title { margin-bottom: 4px !important; }
    .uhiLegendPanel .row   { margin: 2px 0 !important; }
    .uhiLegendPanel .sw{ width: 12px !important; height: 12px !important; margin-right: 6px !important; border-radius: 3px !important; }

    html, body, #cesiumContainer { margin:0; padding:0; width:100%; height:100%; overflow:hidden; }

    /* Discrete (vertical) legend â€” TOP RIGHT */
    .uhiLegendPanel{
      position:absolute;
      z-index:50;
      background:rgba(0,0,0,0.6); color:white; border-radius:12px; padding:10px 12px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; font-size:12px; width:200px;
      box-shadow:0 6px 14px rgba(0,0,0,.25); backdrop-filter: blur(2px);
    }
    #uhiLegendRight { right:1rem; top:6rem; }
    .uhiLegendPanel .title{ font-weight:700; margin-bottom:6px; }
    .uhiLegendPanel .row{ display:flex; align-items:center; margin:3px 0; }
    .uhiLegendPanel .sw{
      width:16px; height:16px; border-radius:3px; margin-right:8px;
      border:1px solid rgba(255,255,255,.4);
    }
    .hidden{ display:none; }

    /* Tooltip */
    #tooltip {
      position:absolute; background:white; border:1px solid #ccc; padding:6px 8px; font-size:13px; pointer-events:none;
      border-radius:6px; box-shadow:0 2px 8px rgba(0,0,0,.15); z-index:1000; max-width:240px; display:none;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    }

    /* Draggable panels */
    .drag-handle { cursor: move; user-select: none; -webkit-user-select: none; }
    .dragging    { opacity: .95; }

    .panel { position:absolute; }
    .panel .panel-tools {
      position:absolute; right:8px; top:6px; display:flex; gap:6px; z-index:5;
    }
    .panel .toolbtn{
      width:22px; height:22px; line-height:22px; text-align:center;
      font-size:12px; border-radius:6px; background:rgba(0,0,0,.06);
      border:1px solid rgba(0,0,0,.08); cursor:pointer; user-select:none;
    }
    .panel-collapsed .panel-body{ display:none; }
    .panel .resize-handle{
      position:absolute; right:6px; bottom:6px; width:14px; height:14px;
      border-right:2px solid rgba(0,0,0,.25); border-bottom:2px solid rgba(0,0,0,.25);
      cursor:nwse-resize; opacity:.6;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>

  <!-- Control Panel -->
  <div id="controlPanel" class="absolute top-4 left-4 bg-white/90 p-4 rounded-xl shadow-lg w-80 space-y-4 z-10 font-sans">
    <div class="drag-handle -mt-1 -mx-1 mb-2 px-1 py-1 text-[11px] text-gray-500 rounded cursor-move select-none">
      â ¿ Drag panel
    </div>

    <div class="text-lg font-semibold">Varna Digital Twin</div>

    <div class="grid grid-cols-2 gap-3">
      <div class="col-span-2">
        <label class="block font-medium">Select Building</label>
        <select id="buildingSelector" class="w-full border rounded px-2 py-1">
          <option value="">-- All Buildings --</option>
        </select>
      </div>

      <div>
        <label class="block font-medium">Base Color</label>
        <input type="color" id="colorPicker" class="w-full" value="#cccccc" />
      </div>

      <div>
        <label class="block font-medium">Color Mode</label>
        <select id="colorMode" class="w-full border rounded px-2 py-1">
          <option value="continuous">Continuous</option>
          <option value="quantile" selected>Quantile (discrete)</option>
        </select>
      </div>

      <div class="col-span-2">
        <label class="block font-medium">Palette</label>
        <select id="palette" class="w-full border rounded px-2 py-1">
          <option value="bluered">Blueâ†’Red</option>
          <option value="spectral" selected>Spectral</option>
          <option value="viridis">Viridis</option>
        </select>
      </div>

      <div class="col-span-2">
        <label class="block font-medium">Color Bins (diversity)</label>
        <input type="range" id="binCount" min="8" max="32" step="1" value="20" class="w-full" />
        <div class="text-xs text-gray-600 mt-1">Bins: <span id="binCountLabel">20</span></div>
      </div>

      <div class="col-span-2">
        <label class="block font-medium">Time of Day</label>
        <input type="range" id="timeSlider" min="0" max="24" step="1" value="12" class="w-full" />
        <div class="text-sm text-gray-600 flex items-center justify-between">
          <span id="timeLabel">12:00</span>
          <div class="space-x-2">
            <button data-mins="0"  class="snapBtn text-xs px-2 py-1 rounded bg-gray-100">Now</button>
            <button data-mins="10" class="snapBtn text-xs px-2 py-1 rounded bg-gray-100">+10m</button>
            <button data-mins="30" class="snapBtn text-xs px-2 py-1 rounded bg-gray-100">+30m</button>
            <button data-mins="60" class="snapBtn text-xs px-2 py-1 rounded bg-gray-100">+60m</button>
          </div>
        </div>
      </div>

      <div>
        <label class="inline-flex items-center"><input type="checkbox" id="heatToggle" checked class="mr-2" /> Show Heat Colors</label>
      </div>
      <div>
        <label class="inline-flex items-center"><input type="checkbox" id="shadowToggle" checked class="mr-2" /> Enable Shadows</label>
      </div>
      <div class="col-span-2">
        <label class="inline-flex items-center"><input type="checkbox" id="predictionToggle" checked class="mr-2" /> Show Predicted Heat</label>
        <div id="modelBadge" class="text-[11px] text-gray-600 mt-1">Forecast: Holt-Winters (Web Worker)</div>
      </div>

      <div class="col-span-2">
        <label class="block font-medium">Traffic Heatmap Time</label>
        <select id="heatmapTimeSelector" class="w-full border rounded px-2 py-1">
          <option value="morning">Morning</option>
          <option value="lunch">Lunch</option>
          <option value="evening">Evening</option>
          <option value="night">Night</option>
        </select>

        <label class="inline-flex items-center mt-2">
          <input type="checkbox" id="heatmapDotsToggle" class="mr-2" />
          Show Heatmap Dots
        </label>
      </div>

      <div class="col-span-2">
        <label class="inline-flex items-center"><input type="checkbox" id="liveTrafficToggle" class="mr-2" /> Live Traffic (TomTom)</label>
        <select id="trafficRefresh" class="w-full border rounded px-2 py-1 mt-2">
          <option value="15" selected>Refresh: 15s</option>
          <option value="30">Refresh: 30s</option>
          <option value="60">Refresh: 60s</option>
        </select>
      </div>
    </div>
  </div>

  <!-- UHI legend (TOP RIGHT) -->
  <div id="uhiLegendRight" class="uhiLegendPanel hidden">
    <div class="title drag-handle">Colors by UHI</div>
    <div id="uhiLegendRowsRight"></div>
  </div>

  <div id="tooltip"></div>

  <!-- Small tiles -->
  <div id="pollutionPanel" class="absolute bottom-4 right-4 bg-white/90 p-4 rounded-xl shadow-lg w-72 space-y-2 z-10 font-sans text-sm">
    <div class="drag-handle -mt-1 -mx-1 mb-1 px-1 py-1 text-[11px] text-gray-500 rounded cursor-move select-none">
      â ¿ Drag
    </div>
    <div class="font-semibold text-gray-700">Predicted Pollution (now)</div>
    <div id="pollutionOutput">Loading...</div>
    <div id="pollutionStamp" class="text-[11px] text-gray-600">â€”</div>
  </div>

  <!-- Time-series chart -->
  <div id="pollutionChartPanel"
       class="absolute bottom-4 left-1/2 -translate-x-1/2 bg-white/90 p-4 rounded-xl shadow-lg w-[900px] z-10 font-sans">
    <div class="flex items-center justify-between drag-handle">
      <div class="text-lg font-semibold">Pollution â€” Trends & Peaks</div>
      <div class="text-xs text-gray-600" id="pollutionChartStatus">â€”</div>
    </div>

    <div class="grid grid-cols-7 gap-3 mt-3">
      <div class="col-span-2">
        <label class="block text-sm font-medium">Pollutant</label>
        <select id="chartPollutant" class="w-full border rounded px-2 py-1">
  <option value="O3">O3</option>
  <option value="NO2">NO2</option>
  <option value="NO">NO</option>
  <option value="CO">CO</option>
  <option value="NH3">NH3</option>
  <option value="Noise">Noise</option>

  <option value="PM10">PM10</option>
  <option value="PM25">PM2.5</option>
  <option value="SO2">SO2</option>
  <option value="B">B (benzene)</option>
</select>

      </div>
      <div class="col-span-2">
        <label class="block text-sm font-medium">Granularity</label>
        <select id="chartGranularity" class="w-full border rounded px-2 py-1">
          <option value="10m">10 minutes</option>
          <option value="hour" selected>Hourly</option>
          <option value="day">Daily</option>
        </select>
      </div>
      <div>
        <label class="block text-sm font-medium">Days back</label>
        <select id="chartDaysBack" class="w-full border rounded px-2 py-1">
          <option value="1">1 day</option><option value="3">3 days</option><option value="7" selected>7 days</option>
        </select>
      </div>
      <div>
        <label class="block text sm font-medium">Forecast</label>
        <select id="chartHorizon" class="w-full border rounded px-2 py-1">
          <option value="0">Off</option>
          <option value="24">Next 24 hours</option>
          <option value="168" selected>Next 7 days</option>
        </select>
      </div>
      <div class="flex items-end">
        <label class="inline-flex items-center">
          <input id="chartShowPred" type="checkbox" class="mr-2" checked /> Show Predicted
        </label>
      </div>

      <div>
        <label class="block text-sm font-medium">Threshold</label>
        <input id="chartThreshold" type="number" step="0.1" class="w-full border rounded px-2 py-1" />
      </div>
    </div>

    <div class="mt-3">
      <canvas id="pollutionChart" height="110"></canvas>
    </div>

    <div class="mt-2 text-[12px] text-gray-600">
      Tips: hover for exact values â€¢ peaks are highlighted â€¢ switch granularity for smoother trends.
    </div>
  </div>

  <!-- ICT / Ops panel -->
  <div id="ictPanel"
       class="absolute top-4 right-4 bg-white/90 p-4 rounded-xl shadow-lg w-[520px] z-20 font-sans">
    <div class="drag-handle -mt-1 -mx-1 mb-2 px-1 py-1 text-[11px] text-gray-500 rounded cursor-move select-none">â ¿ Drag</div>

    <div class="flex items-center justify-between">
      <div class="text-lg font-semibold">System Health</div>
      <div id="ictStamp" class="text-xs text-gray-500">â€”</div>
    </div>

    <div class="grid grid-cols-3 gap-3 mt-3 text-sm">
      <div class="p-3 rounded-xl bg-green-50 border border-green-200">
        <div class="text-[11px] text-green-700">Uptime (24h)</div>
        <div id="ictUptime" class="text-xl font-semibold text-green-800">â€”</div>
      </div>
      <div class="p-3 rounded-xl bg-blue-50 border border-blue-200">
        <div class="text-[11px] text-blue-700">Latest update</div>
        <div id="ictLatest" class="text-xl font-semibold text-blue-800">â€”</div>
      </div>
      <div class="p-3 rounded-xl bg-violet-50 border border-violet-200">
        <div class="text-[11px] text-violet-700">API latency</div>
        <div id="ictLatency" class="text-xl font-semibold text-violet-800">â€”</div>
      </div>
    </div>

    <div class="mt-3">
      <canvas id="ictChart" style="height:130px; width:100%;"></canvas>
    </div>

    <div class="mt-2 text-[12px] text-gray-600">
      Bars: updates/hour â€¢ Line: API latency (ms). Expected ~6 updates/hour with a 10-min cron.
    </div>
  </div>

  <script type="module">
    // ==========================
    // ðŸ”‘ KEYS
    // ==========================
    const weatherApiKey = "2d6c23f739fdc7ba90b8754fd02dae9c";
    const tomtomKey     = "j1Z1JoCDAq3ia7s4XaLTTd8Ip6G3nzZ5";
    Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJjODA1Mzg0My0zMDBjLTQ4MDEtODlmOC01OTc4M2QyODllYWEiLCJpZCI6MzA0ODA3LCJpYXQiOjE3NjA5NTUyMjJ9.G754yiSXNU-RMeD3mwyIH6W6sIU-dEwNrrdqOp8uCXk";

    // Optional backend (predict/backfill); app works without it
    const POLLUTION_API = "https://culture-powell-stable-devel.trycloudflare.com";

    // ======== CLOUD SYNC SETTINGS (NEW) ========
    const CLOUD_SYNC_ENABLED = !!POLLUTION_API;
    const SYNC_KEY = "pollution_is_sync_v1";
    const DEVICE_KEY = "device_id_v1";

    function getDeviceId(){
      try{
        let id = localStorage.getItem(DEVICE_KEY);
        if (!id) { id = crypto?.randomUUID?.() || String(Math.random()).slice(2); localStorage.setItem(DEVICE_KEY, id); }
        return id;
      }catch{ return "anon"; }
    }
    function getLastSynced(){
      try { return JSON.parse(localStorage.getItem(SYNC_KEY)) || { lastTs: 0 }; } catch { return { lastTs: 0 }; }
    }
    function setLastSynced(ts){
      try { localStorage.setItem(SYNC_KEY, JSON.stringify({ lastTs: ts })); } catch {}
    }

    // ==========================
    // App-wide state
    // ==========================
    let viewer, buildings = [], heatmapEntities = [];
    let trafficLayer = null, trafficTimer = null;

    const histories = {
  urbanTemp: [], O3: [], NO2: [], NO: [], CO: [], NH3: [], Noise: [], PM10: [], PM25: [], SO2: [], B: [] };
    let lastWeather = { temp: null, wind: 0, clouds: 0, humidity: 0, pressure: 0, rain1h: 0 };

    const STEP_MINUTES  = 60;              // hourly steps
    const HORIZON_STEPS = 7 * 24;          // next 7 days

    // ==========================
    // Utility
    // ==========================
    async function resilientFetch(url, tries=3, base=500){
      for (let i=0;i<tries;i++){
        const r = await fetch(url, { cache: "no-store" });
        if (r.ok) return r;
        await new Promise(res => setTimeout(res, base * 2**i + Math.random()*200));
      }
      throw new Error("fetch failed: " + url);
    }
    const clamp01 = (x)=>Math.max(0,Math.min(1,x));
    const lerp = (a,b,t)=>a + (b-a)*t;

    // ==========================
    // UHI color ramp (continuous) â€“ Spectral stops
    // ==========================
    let UHI_MIN = 25, UHI_MAX = 40;
    let UHI_AUTOSCALE = true;

    let DECIMALS = 2;
    const POW = 100;
    const fmt = (x) => (Number.isFinite(x) ? x.toFixed(DECIMALS) : "â€”");

    const MIN_SPAN = 2.0;
    function quantile(sorted, p){
      if (!sorted.length) return NaN;
      const i = (sorted.length - 1) * p;
      const lo = Math.floor(i), hi = Math.ceil(i);
      if (lo === hi) return sorted[lo];
      return sorted[lo] + (sorted[hi] - sorted[lo]) * (i - lo);
    }

    const UHI_STOPS = [
      { p: 0.00,  c: Cesium.Color.fromBytes(94, 79,162,255) },
      { p: 0.125, c: Cesium.Color.fromBytes(50,136,189,255) },
      { p: 0.25,  c: Cesium.Color.fromBytes(153,213,148,255) },
      { p: 0.50,  c: Cesium.Color.fromBytes(230,245,152,255) },
      { p: 0.75,  c: Cesium.Color.fromBytes(254,224,139,255) },
      { p: 0.875, c: Cesium.Color.fromBytes(252,141, 89,255) },
      { p: 1.00,  c: Cesium.Color.fromBytes(213, 62, 79,255) }
    ];
    function interpolateColor(stops,t){
      t = clamp01(t);
      for (let i=1;i<stops.length;i++){
        if (t <= stops[i].p){
          const a=stops[i-1], b=stops[i], w=(t-a.p)/(b.p-a.p);
          return new Cesium.Color(
            lerp(a.c.red,b.c.red,w),
            lerp(a.c.green,b.c.green,w),
            lerp(a.c.blue,b.c.blue,w),
            lerp(a.c.alpha,b.c.alpha,w)
          );
        }
      }
      return stops[stops.length-1].c.clone();
    }
    function uhiToColor(temp, alpha=1){
      const span = Math.max(1e-6, (UHI_MAX - UHI_MIN));
      const t = (temp - UHI_MIN) / span;
      const c = interpolateColor(UHI_STOPS, t);
      return new Cesium.Color(c.red, c.green, c.blue, alpha);
    }

    function getEntityTemp(ent){
      const usePred = document.getElementById("predictionToggle")?.checked;
      const props = ent.properties;
      if (usePred && props?.pred_uhi?.getValue) {
        const when = Cesium.JulianDate.now();
        const val = props.pred_uhi.getValue(when);
        if (typeof val === "number") return val;
      }
      const sim = props?.sim_uhi?.getValue?.() ?? props?.sim_uhi;
      return (typeof sim === "number") ? sim : undefined;
    }

    function computeCurrentUHIBounds(){
      if (!UHI_AUTOSCALE) return;
      const vals = [];
      for (const b of buildings){
        const v = getEntityTemp(b);
        if (typeof v === "number" && isFinite(v)) vals.push(v);
      }
      if (!vals.length) return;
      vals.sort((a,b)=>a-b);
      let min = quantile(vals, 0.05);
      let max = quantile(vals, 0.95);
      if ((max - min) < 2.0){
        const mid = (min + max)/2;
        min = mid - 1.0; max = mid + 1.0;
      }
      UHI_MIN = Math.floor(min * POW) / POW;
      UHI_MAX = Math.ceil (max * POW) / POW;
    }

    // ==========================
    // Discrete palettes & helpers
    // ==========================
    const PALETTES = {
      bluered:  ['#313695','#4575b4','#74add1','#fee090','#fdae61','#f46d43','#d73027'],
      spectral: ['#5E4FA2','#3288BD','#99D594','#E6F598','#FEE08B','#FC8D59','#D53E4F'],
      viridis:  ['#440154','#472D7B','#3B528B','#2C728E','#21918C','#5EC962','#FDE725']
    };
    function hexToCesium(hex, a=1){
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if(!m) return Cesium.Color.WHITE.withAlpha(a);
      return new Cesium.Color(parseInt(m[1],16)/255, parseInt(m[2],16)/255, parseInt(m[3],16)/255, a);
    }
    function interpPalette(hexStops, n){
      if (n <= hexStops.length) {
        return Array.from({length:n}, (_,i)=>hexStops[Math.round(i*(hexStops.length-1)/(n-1))]);
      }
      const pos = hexStops.map((_,i)=>i/(hexStops.length-1));
      function hexToRGB(h){ return [parseInt(h.slice(1,3),16),parseInt(h.slice(3,5),16),parseInt(h.slice(5,7),16)]; }
      const rgb = hexStops.map(hexToRGB);
      const out = [];
      for (let i=0;i<n;i++){
        const t = (n===1)?0:i/(n-1);
        let k=1; while(k<pos.length && t>pos[k]) k++;
        const a = Math.max(1,k)-1, b = Math.min(pos.length-1,k);
        const w = (t - pos[a]) / Math.max(1e-6,(pos[b]-pos[a]));
        const c = [0,1,2].map(j=>Math.round( rgb[a][j] + (rgb[b][j]-rgb[a][j])*w ));
        out.push(`#${c.map(v=>v.toString(16).padStart(2,'0')).join('')}`);
      }
      return out;
    }
    function quantileBreaks(values, k=20){
      const v = values.filter(Number.isFinite).slice().sort((a,b)=>a-b);
      if(!v.length) return [];
      const br = [];
      for(let i=1;i<=k;i++){
        const p = i/k;
        const idx = Math.min(v.length-1, Math.max(0, Math.round(p*(v.length-1))));
        br.push(v[idx]);
      }
      for(let i=1;i<br.length;i++){ if(br[i] <= br[i-1]) br[i] = br[i-1] + 1e-6; }
      return br;
    }
    function colorFromBins(x, breaks, colors, alpha=1){
      for(let i=0;i<breaks.length;i++){ if(x <= breaks[i]) return hexToCesium(colors[i], alpha); }
      return hexToCesium(colors[colors.length-1], alpha);
    }

    // ===== Legend helpers (RIGHT ONLY) =====
    function renderDiscreteLegends(breaksAsc, colors, minVal){
      const lowers = [minVal].concat(breaksAsc.slice(0, -1));
      let html = "";
      for (let i = lowers.length - 1; i >= 0; i--){
        html += `<div class="row"><div class="sw" style="background:${colors[i]}"></div><span>&ge; ${fmt(lowers[i])}</span></div>`;
      }
      const right = document.getElementById("uhiLegendRight");
      const rows  = document.getElementById("uhiLegendRowsRight");
      rows.innerHTML = html;
      right.classList.remove("hidden");
    }
    function hideDiscreteLegends(){
      document.getElementById("uhiLegendRight").classList.add("hidden");
    }

    // ==========================
    // Forecast worker (Holt-Winters)
    // ==========================
    const workerCode = `
      self.onmessage = (e) => {
        const { kind, payload } = e.data || {};
        if (kind === "FORECAST") {
          const { histories, horizon } = payload;
          function hw(series, a=0.5,b=0.3,g=0.2, m=24, h=168){
            if (!series || series.length < 3) return Array(h).fill(series && series[series.length-1] || 0);
            const L=[series[0]], T=[series[1]-series[0]], S = new Array(m).fill(0);
            for(let t=1;t<series.length;t++){
              const s=S[(t-1)%m];
              const l=a*(series[t]-s)+(1-a)*(L[t-1]+T[t-1]);
              const tt=b*(l-L[t-1])+(1-b)*T[t-1];
              S[t%m]=g*(series[t]-l)+(1-g)*s;
              L[t]=l; T[t]=tt;
            }
            const last=series.length-1;
            return Array.from({length:h},(_,i)=>(L[last]+(i+1)*T[last])+S[(last+1+i)%m]);
          }
          function ensure(series, seed=20){
            if (!series || series.length===0) return [seed, seed*1.02, seed*1.01, seed*1.03];
            return series;
          }
          const out = {
  urbanTemp: hw(ensure(histories.urbanTemp, 28), 0.5,0.3,0.2, 24, horizon),
  O3:    hw(ensure(histories.O3,   80), 0.5,0.3,0.2, 24, horizon),
  NO2:   hw(ensure(histories.NO2,  30), 0.5,0.3,0.2, 24, horizon),
  NO:    hw(ensure(histories.NO,   20), 0.5,0.3,0.2, 24, horizon),
  CO:    hw(ensure(histories.CO,  1.0), 0.5,0.3,0.2, 24, horizon),
  NH3:   hw(ensure(histories.NH3, 1.0), 0.5,0.3,0.2, 24, horizon),
  Noise: hw(ensure(histories.Noise, 60), 0.5,0.3,0.2, 24, horizon),

  PM10:  hw(ensure(histories.PM10, 35), 0.5,0.3,0.2, 24, horizon),
  PM25:  hw(ensure(histories.PM25, 20), 0.5,0.3,0.2, 24, horizon),
  SO2:   hw(ensure(histories.SO2, 10), 0.5,0.3,0.2, 24, horizon),
  B:     hw(ensure(histories.B,    3), 0.5,0.3,0.2, 24, horizon)
};

          postMessage({ kind:"PREDICTIONS", data: out, ts: Date.now() });
        }
      };
    `;
    const worker = new Worker(URL.createObjectURL(new Blob([workerCode], {type:'application/javascript'})));
    let latestPredictions = null;
    worker.onmessage = (e) => {
      if (e.data?.kind === "PREDICTIONS") {
        latestPredictions = e.data.data;
        updatePredictedUHIForBuildings();
        paintPollutionPanelNow();
        syncPredictionSeries();
      }
    };

    async function predictWithAPI(weather) {
      const features = {
        Temperature: weather.temp,
        Humidity: weather.humidity,
        Precipitation: (weather.rain1h || 0),
        WindSpeed_m_s: weather.wind
      };
      try {
        const r = await fetch(`${POLLUTION_API}/predict`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(features)
        });
        if (!r.ok) throw new Error("API error");
        return await r.json();
      } catch (e) {
        console.warn("Model API failed, using heuristic", e);
        return null;
      }
    }

    function estimateNoiseFromContext(w){
      const tod = document.getElementById("heatmapTimeSelector")?.value ||
                  ((h)=> h<6?'night': h<10?'morning': h<16?'lunch': h<21?'evening':'night')((new Date()).getHours());
      const baseByTod = { morning:64, lunch:60, evening:66, night:52 };
      let val = baseByTod[tod] ?? 60;

      const live = document.getElementById("liveTrafficToggle")?.checked;
      const wind = w?.wind || 0;
      const rain = w?.rain1h || 0;

      if (!live) val -= 2;
      val -= 0.4 * Math.max(0, wind - 1.0);
      if (rain > 0) val -= 1.5;

      const cap = (x,min,max)=>Math.max(min, Math.min(max, x));
      return cap(val, 40, 85);
    }

    // ==========================
    // Weather + UHI (realtime) â€” VARNA
    // ==========================
    async function fetchUHIAndUpdate(){
      // Varna center (urban) and a rural reference ~8â€“10 km WNW
      const urbanURL = `https://api.openweathermap.org/data/2.5/weather?lat=43.214&lon=27.914&units=metric&appid=${weatherApiKey}`;
      const ruralURL = `https://api.openweathermap.org/data/2.5/weather?lat=43.214&lon=27.814&units=metric&appid=${weatherApiKey}`;

      try {
        const [uRes, rRes] = await Promise.all([resilientFetch(urbanURL), resilientFetch(ruralURL)]);
        const uJson = await uRes.json();
        const rJson = await rRes.json();

        const urbanTemp = uJson.main?.temp ?? 28;

        lastWeather = {
          temp: urbanTemp,
          wind: uJson.wind?.speed ?? 1.5,
          clouds: uJson.clouds?.all ?? 20,
          humidity: uJson.main?.humidity ?? 50,
          pressure: uJson.main?.pressure ?? 1013,
          rain1h: (uJson.rain && (uJson.rain["1h"] ?? uJson.rain["h1"])) || 0
        };

        histories.urbanTemp.push(urbanTemp);
        if (histories.urbanTemp.length > 2000) histories.urbanTemp.shift();

        let nowPoll = await predictWithAPI(lastWeather);
        if (!nowPoll) nowPoll = simulatePollutionFromWeather(lastWeather);

        if (typeof nowPoll.Noise !== 'number') nowPoll.Noise = estimateNoiseFromContext(lastWeather);

        for (const k of KEYS) {
  histories[k].push(Number(nowPoll[k]) || 0);
  if (histories[k].length > 2000) histories[k].shift();
}


        syncMeasuredSeries(nowPoll);

        for (const building of buildings) {
          const height = parseFloat(building.properties?.height?.getValue?.() ?? building.properties?.height) || 10;
          const simTemp = computeUHI(urbanTemp, height, lastWeather.wind, lastWeather.clouds);
          building.properties.addProperty("sim_uhi", simTemp);
        }

        requestForecast();
        updateStyles();
        paintPollutionPanelNow();

      } catch (err) {
        console.error("Weather/UHI fetch error:", err);
      }
    }

    function computeUHI(urbanTemp, height, wind, clouds){
      return urbanTemp + 0.03*height - 0.2*wind - 0.02*clouds;
    }

    function simulatePollutionFromWeather(w){
  const { temp, wind, humidity, clouds } = w;
  const cap = (x,min,max)=>Math.max(min, Math.min(max, x));
  const Noise = estimateNoiseFromContext(w);

  return {
    O3:   cap(60 + (temp-20)*2 - clouds*0.3 + wind*-2, 20, 140),
    NO2:  cap(20 + clouds*0.2 + (30 - wind*3), 5, 80),
    NO:   cap(10 + (humidity-50)*0.1 + (30 - wind*4), 2, 70),
    CO:   cap(0.6 + (30 - wind*5)*0.02, 0.2, 3),
    NH3:  cap(0.8 + (humidity-50)*0.01, 0.3, 4),

    PM10: cap(25 + clouds*0.15 + (30 - wind*2),   5, 120),
    PM25: cap(15 + clouds*0.10 + (30 - wind*2.5), 3,  80),
    SO2:  cap(8  + (30 - wind*3)*0.2,             2,  40),
    B:    cap(2  + (humidity-50)*0.02,            0.5,10),

    Noise
  };
}


    function requestForecast(){
      worker.postMessage({
        kind: "FORECAST",
        payload: { histories, horizon: HORIZON_STEPS, stepMinutes: STEP_MINUTES }
      });
    }

    function updatePredictedUHIForBuildings(){
      if (!latestPredictions) return;
      const predUrban = latestPredictions.urbanTemp || [];
      const wind = lastWeather.wind, clouds = lastWeather.clouds;
      const now = Date.now();

      for (const b of buildings) {
        const height = parseFloat(b.properties?.height?.getValue?.() ?? b.properties?.height) || 10;
        const prop = new Cesium.SampledProperty(Number);
        prop.backwardExtrapolationType   = Cesium.ExtrapolationType.HOLD;
        prop.forwardExtrapolationType    = Cesium.ExtrapolationType.HOLD;
        prop.backwardExtrapolationDuration = 24 * 3600;
        prop.forwardExtrapolationDuration  = 7  * 24 * 3600;

        for (let i=0; i<predUrban.length; i++){
          const t = new Date(now + i * STEP_MINUTES * 60 * 1000);
          const uhi = computeUHI(predUrban[i], height, wind, clouds);
          prop.addSample(Cesium.JulianDate.fromDate(t), uhi);
        }
        b.properties.addProperty("pred_uhi", prop);
      }
      viewer.scene.requestRender();
    }

    // ==========================
    // STYLES (continuous + discrete)
    // ==========================
    function updateStyles(){
      if (!viewer || !buildings?.length) return;

      const selected   = document.getElementById("buildingSelector")?.value || "";
      const colorHex   = document.getElementById("colorPicker")?.value || "#cccccc";
      const alpha      = 1.0;
      const showHeat   = document.getElementById("heatToggle")?.checked ?? true;
      const colorMode  = document.getElementById("colorMode")?.value || "quantile";
      const paletteKey = document.getElementById("palette")?.value || "spectral";
      const bins       = parseInt(document.getElementById("binCount")?.value || "20", 10);

      document.getElementById("binCountLabel").textContent = String(bins);

      let breaks = null, colors = null, minVal = null;
      if (showHeat && colorMode === "quantile") {
        const vals = [];
        for (const b of buildings){
          const v = getEntityTemp(b);
          if (typeof v === "number" && isFinite(v)) vals.push(v);
        }
        if (vals.length){
          vals.sort((a,b)=>a-b);
          computeCurrentUHIBounds();
          minVal = vals[0];
          breaks = quantileBreaks(vals, bins);
          const palStops = PALETTES[paletteKey] || PALETTES.spectral;
          colors = interpPalette(palStops, bins);
          renderDiscreteLegends(breaks, colors, minVal);
        } else {
          hideDiscreteLegends();
        }
      } else {
        hideDiscreteLegends();
        computeCurrentUHIBounds();
      }

      for (const building of buildings) {
        if (!building.polygon) continue;
        let color = Cesium.Color.fromCssColorString(colorHex).withAlpha(alpha);
        if (showHeat) {
          let t = getEntityTemp(building);
          if (typeof t === "number" && isFinite(t)) {
            if (colorMode === "quantile" && breaks && colors && breaks.length) {
              color = colorFromBins(t, breaks, colors, alpha);
            } else {
              color = uhiToColor(t, alpha);
            }
          }
        }
        if (!selected || building.name === selected) {
          building.polygon.material = color;
        }
      }
      viewer.scene.requestRender();
    }

    // ==========================
    // Time-series chart wiring (unchanged)
    // ==========================
    const tsStore = {
  O3: [], NO2: [], NO: [], CO: [], NH3: [], Noise: [],
  PM10: [], PM25: [], SO2: [], B: [],
  pred: {
    O3: [], NO2: [], NO: [], CO: [], NH3: [], Noise: [],
    PM10: [], PM25: [], SO2: [], B: []
  }
};

    const RETENTION_DAYS = 7;
    const STORE_KEY = "pollution_ts_v1";
    const KEYS = ["O3","NO2","NO","CO","NH3","Noise","PM10","PM25","SO2","B"];

    function pruneOldData() {
      const cutoff = Date.now() - RETENTION_DAYS * 24 * 3600 * 1000;
      for (const k of KEYS) tsStore[k] = (tsStore[k] || []).filter(p => p.ts >= cutoff && Number.isFinite(p.v));
      return cutoff;
    }
    function saveTsStore() {
      pruneOldData();
      const cap = (arr, n = 100000) => (arr.length > n ? arr.slice(arr.length - n) : arr);
      const payload = {
  O3: cap(tsStore.O3),
  NO2: cap(tsStore.NO2),
  NO: cap(tsStore.NO),
  CO: cap(tsStore.CO),
  NH3: cap(tsStore.NH3),
  Noise: cap(tsStore.Noise),
  PM10: cap(tsStore.PM10),
  PM25: cap(tsStore.PM25),
  SO2: cap(tsStore.SO2),
  B: cap(tsStore.B)
};
      try { localStorage.setItem(STORE_KEY, JSON.stringify(payload)); } catch {}
      syncToCloud();
    }
    function loadTsStore() {
      try {
        const raw = localStorage.getItem(STORE_KEY); if (!raw) return;
        const obj = JSON.parse(raw);
        for (const k of KEYS) {
          const arr = Array.isArray(obj[k]) ? obj[k] : [];
          tsStore[k] = arr.map(p => ({ ts: Number(p.ts), v: Number(p.v) }))
                         .filter(p => Number.isFinite(p.ts) && Number.isFinite(p.v));
        }
        pruneOldData();
      } catch {}
    }

    function pushMeasured(k, ts, val){ tsStore[k].push({ ts, v: Number(val) }); }
    function setPredictedHorizon(predObj, baseTs=Date.now()){
      const stepMs = STEP_MINUTES * 60 * 1000;
      for (const k of KEYS){
        const pred = (predObj?.[k] || []).map((v, i)=>({ ts: baseTs + i*stepMs, v: Number(v) }));
        tsStore.pred[k] = pred;
      }
    }
    function aggregateSeries(points, mode){
      if (!points.length) return [];
      const bucketStart = (t)=> {
        const d = new Date(t);
        if (mode === "day") { d.setHours(0,0,0,0); return d.getTime(); }
        if (mode === "hour"){ d.setMinutes(0,0,0);  return d.getTime(); }
        const m = Math.floor(d.getMinutes()/10)*10; d.setMinutes(m,0,0); return d.getTime();
      };
      const buckets = new Map();
      for (const p of points){
        const key = bucketStart(p.ts);
        const b = buckets.get(key) || { sum:0, n:0, max:-Infinity, min:Infinity };
        b.sum += p.v; b.n += 1; b.max = Math.max(b.max, p.v); b.min = Math.min(b.min, p.v);
        buckets.set(key, b);
      }
      return Array.from(buckets.entries()).sort((a,b)=>a[0]-b[0]).map(([t,b])=>({ t: Number(t), v: b.sum/b.n }));
    }
    function sliceDaysBack(points, days){
      const cutoff = Date.now() - days*24*3600*1000;
      return points.filter(p=>p.ts >= cutoff);
    }

    const UNITS = { O3:"Âµg/mÂ³", NO2:"Âµg/mÂ³", NO:"Âµg/mÂ³", CO:"ppm", NH3:"Âµg/mÂ³", Noise:"dB(A)", PM10:"Âµg/mÂ³", PM25:"Âµg/mÂ³", SO2:"Âµg/mÂ³", B:"Âµg/mÂ³"};
    const THRESHOLDS = {
  O3:100,
  NO2:40,
  NO:50,
  CO:10,
  NH3:2,
  Noise:65,
  PM10:40,   // Âµg/mÂ³
  PM25:25,   // Âµg/mÂ³
  SO2:20,    // Âµg/mÂ³
  B:5        // Âµg/mÂ³ (benzene)
};

const LABELS = {
  PM25: "PM2.5",
  B: "B (benzene)"
};

    const thresholdPlugin = {
      id: 'thresholdLine',
      afterDatasetsDraw(chart, args, opts) {
        const {ctx, chartArea, scales} = chart;
        const y = scales.y.getPixelForValue(opts.value);
        if (!isFinite(y) || y < chartArea.top || y > chartArea.bottom) return;
        ctx.save();
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(chartArea.left, y);
        ctx.lineTo(chartArea.right, y);
        ctx.stroke();
        ctx.restore();
      }
    };

    const dayLinesPlugin = {
      id: 'dayLines',
      beforeDatasetsDraw(chart, args, opts) {
        const { ctx, chartArea, scales } = chart;
        const x = scales.x;
        if (!x || x.type !== 'time') return;

        const start = x.getValueForPixel(chartArea.left);
        const end   = x.getValueForPixel(chartArea.right);
        if (!isFinite(start) || !isFinite(end)) return;

        const d0 = new Date(start);
        d0.setHours(0,0,0,0);
        if (d0.getTime() < start) d0.setDate(d0.getDate() + 1);

        ctx.save();
        ctx.setLineDash([4,4]);
        ctx.lineWidth = 1;

        for (let t = d0.getTime(); t <= end; t += 24*3600*1000) {
          const xp = x.getPixelForValue(t);
          ctx.strokeStyle = 'rgba(0,0,0,0.18)';
          ctx.beginPath();
          ctx.moveTo(xp, chartArea.top);
          ctx.lineTo(xp, chartArea.bottom);
          ctx.stroke();

          if (opts?.showLabels) {
            const lab = new Date(t).toLocaleDateString();
            ctx.fillStyle = 'rgba(0,0,0,0.65)';
            ctx.font = '10px system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(lab, xp, chartArea.bottom - 4);
          }
        }
        ctx.restore();
      }
    };

    Chart.register(thresholdPlugin);
    Chart.register(dayLinesPlugin);

    const CH_BLUE_MEASURED  = '#2563eb';
    const CH_BLUE_PREDICTED = '#3b82f6';
    const CH_BLUE_BAND      = 'rgba(59,130,246,0.10)';

    let pollutionChart = null;
    function ensureChart(){
      const ctx = document.getElementById("pollutionChart").getContext("2d");
      if (pollutionChart) return pollutionChart;
      pollutionChart = new Chart(ctx, {
        type: "line",
        data: { datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          animation: false,
          interaction: { mode: "index", intersect: false },
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                filter: (item, data) => {
                  const ds = data?.datasets?.[item.datasetIndex];
                  return ds && !ds.skipLegend && item.text;
                }
              }
            },
            tooltip: { callbacks: { label: (tt)=>{
              const pol = tt.dataset.metaPollutant || '';
              const unit = UNITS[pol] || '';
              return `${tt.dataset.label}: ${Number(tt.parsed.y).toFixed(2)}${unit ? ' ' + unit : ''}`;
            } } },
            thresholdLine: { value: 0 },
            dayLines: { showLabels: true }
          },
          scales: {
            x: { type: "time" },
            y: { title: { display: true, text: "concentration (Âµg/mÂ³ or ppm)" } }
          },
          elements: { point: { radius: 0 }, line: { tension: 0.25 } }
        }
      });
      return pollutionChart;
    }

    function findPeaks(points){
      if (!points || points.length < 3) return [];
      const ys = points.map(p=>p.y);
      const mean = ys.reduce((s,y)=>s+y,0)/ys.length;
      const sd = Math.sqrt(ys.reduce((s,y)=>s+(y-mean)*(y-mean),0)/ys.length) || 0;
      const minProm = Math.max(0.0001, sd*0.8);
      const out = [];
      for (let i=1;i<points.length-1;i++){
        const y = points[i].y, yl = points[i-1].y, yr = points[i+1].y;
        if (y > yl && y > yr && (y - Math.max(yl, yr) >= minProm)) out.push(points[i]);
      }
      return out;
    }
    function buildPredictionBand(measuredAgg, predictedAgg){
      if (!predictedAgg?.length) return { upper:[], lower:[] };
      const N = Math.min(48, measuredAgg.length);
      let sd = 0;
      if (N >= 6){
        const ys = measuredAgg.slice(-N).map(p=>p.y);
        const mean = ys.reduce((s,y)=>s+y,0)/ys.length;
        sd = Math.sqrt(ys.reduce((s,y)=>s+(y-mean)*(y-mean),0)/ys.length);
      }
      return {
        lower: predictedAgg.map(p => ({ x:p.x, y: p.y - (sd || p.y*0.15) })),
        upper: predictedAgg.map(p => ({ x:p.x, y: p.y + (sd || p.y*0.15) }))
      };
    }

    function renderPollutionChart(){
      const chart = ensureChart();
      const pollutant = document.getElementById("chartPollutant").value;
      const gran = document.getElementById("chartGranularity").value;
      const name = LABELS[pollutant] || pollutant;
      const daysBack = parseInt(document.getElementById("chartDaysBack").value, 10);
      const showPred = document.getElementById("chartShowPred").checked;
      const horizonHrs = parseInt(document.getElementById("chartHorizon").value, 10);

      chart.options.scales.x.time.unit =
        (gran === 'day' ? 'day' : (gran === 'hour' ? 'hour' : 'minute'));

      const measuredAgg = aggregateSeries(
        sliceDaysBack(tsStore[pollutant] || [], daysBack), gran
      ).map(p=>({ x:p.t, y:p.v }));

      let predictedAgg = [];
      if (showPred && horizonHrs > 0) {
        const now = Date.now(), horizonMs = horizonHrs * 3600 * 1000;
        const future = (tsStore.pred?.[pollutant] || [])
          .filter(p => p.ts >= now && p.ts <= now + horizonMs);
        predictedAgg = aggregateSeries(future, gran).map(p=>({ x:p.t, y:p.v }));
      }

      const thr = Number.isFinite(THRESHOLDS[pollutant]) ? THRESHOLDS[pollutant] : Infinity;
      const peaks = findPeaks(measuredAgg);
      const band  = buildPredictionBand(measuredAgg, predictedAgg);
      const unit  = UNITS[pollutant] || '';

      const dsMeasured = {
        label: `${name} (measured)`,
        data: measuredAgg,
        borderWidth: 3,
        borderColor: CH_BLUE_MEASURED,
        backgroundColor: 'transparent',
        pointRadius: 0,
        metaPollutant: pollutant,
        order: 20
      };

      const datasets = [dsMeasured];

      if (showPred && predictedAgg.length){
        const dsPredLower = {
          label: "",
          skipLegend: true,
          data: band.lower,
          borderWidth: 0, pointRadius: 0, fill: false,
          metaPollutant: pollutant, order: 5
        };
        const dsPredUpper = {
          label: `${name} (forecast â€” uncertainty)`,
          data: band.upper,
          borderWidth: 0, pointRadius: 0, fill: { target: "-1" },
          backgroundColor: CH_BLUE_BAND,
          metaPollutant: name, order: 6
        };
        const dsPred = {
          label: `${pollutant} (forecast)`,
          data: predictedAgg,
          borderWidth: 2, borderDash: [8,6], borderColor: CH_BLUE_PREDICTED,
          pointRadius: 0, metaPollutant: pollutant, order: 10
        };
        datasets.push(dsPredLower, dsPredUpper, dsPred);
      }

      if (peaks.length){
        datasets.push({
          type: 'scatter',
          label: `${name} â€” peaks`,
          data: peaks,
          pointRadius: 4, pointHoverRadius: 6,
          pointBackgroundColor: 'rgba(220, 38, 38, 0.9)',
          showLine: false, metaPollutant: pollutant, order: 30
        });
      }

      chart.data.datasets = datasets;
      chart.options.scales.y.title.text = `${name} (${unit})`;
      chart.options.plugins.thresholdLine.value = thr;

      document.getElementById("pollutionChartStatus").textContent =
        `${name} â€¢ granularity: ${gran} â€¢ past: ${daysBack}d â€¢ future: ${horizonHrs}h â€¢ pts: ${measuredAgg.length}`;

      chart.update();

      const thrInput = document.getElementById('chartThreshold');
      if (thrInput && document.activeElement !== thrInput) thrInput.value = String(thr);
    }

    async function backfillHistory(days=7){
      try{
        const r = await fetch(`${POLLUTION_API}/history?days=${days}`, { cache: "no-store" });
        if (!r.ok) throw new Error("history api error");
        const rows = await r.json();
        for (const row of rows){
          const ts = Number(row.ts); if (!Number.isFinite(ts)) continue;
          for (const k of KEYS){ if (k in row) pushMeasured(k, ts, Number(row[k])); }
        }
        pruneOldData(); saveTsStore(); renderPollutionChart();
      }catch(e){ console.warn("History backfill failed or unavailable:", e); }
    }

    function syncMeasuredSeries(nowPoll){
  const ts = Date.now();
  for (const k of KEYS) pushMeasured(k, ts, Number(nowPoll[k]) || 0);
  saveTsStore();
  renderPollutionChart();
}

    function syncPredictionSeries(){
      const baseTs = Date.now();
      setPredictedHorizon(latestPredictions, baseTs);
      renderPollutionChart();
    }
    function initChartUI(){
      ["chartPollutant","chartGranularity","chartDaysBack","chartShowPred","chartHorizon"]
        .forEach(id=> document.getElementById(id).addEventListener("change", renderPollutionChart));

      const thrInput = document.getElementById('chartThreshold');
      if (thrInput){
        thrInput.addEventListener('change', ()=>{
          const pol = document.getElementById("chartPollutant").value;
          const v = parseFloat(thrInput.value);
          if (Number.isFinite(v)) THRESHOLDS[pol] = v;
          renderPollutionChart();
        });
      }

      renderPollutionChart();
    }

    // ==========================
    // Pollution tiles panel
    // ==========================
    function paintPollutionPanelNow(){
  const PANEL_KEYS = ["PM10","PM25","O3","NO2","NO","SO2","B","CO","NH3","Noise"];

  let out = {};
  if (latestPredictions) {
    for (const k of PANEL_KEYS) {
      if (Array.isArray(latestPredictions[k]) && latestPredictions[k].length) {
        out[k] = latestPredictions[k][0];
      }
    }
  } else {
    out = histories;
  }

      const level = (p, v)=> v < THRESHOLDS[p]*0.6 ? "bg-green-100 text-green-800"
                             : v < THRESHOLDS[p]     ? "bg-yellow-100 text-yellow-800"
                                                     : "bg-red-100 text-red-800";
        const entries = PANEL_KEYS.map(k=>{
    const v = (out && typeof out[k]==="number")
      ? out[k]
      : (out?.[k]?.slice?.(-1)[0] ?? 0);
    const label = LABELS[k] || k;
    return `<div class="p-2 rounded-lg ${level(k, v)} flex justify-between items-center">
              <span class="font-medium">${label}</span>
              <span class="font-semibold">${(v||0).toFixed(2)}</span>
            </div>`;
  }).join("");

      document.getElementById("pollutionOutput").innerHTML = `<div class="space-y-2">${entries}</div>`;
      document.getElementById("pollutionStamp").textContent = "Updated: " + new Date().toLocaleTimeString();
    }

    // ==========================
    // ====== CLOUD SYNC (NEW)
    // ==========================
    function collectPointsSince(cutoffTs){
      const rows = [];
      for (const k of KEYS) {
        for (const p of tsStore[k]) {
          if (p.ts > cutoffTs && Number.isFinite(p.v)) rows.push({ ts: p.ts, pollutant: k, value: p.v });
        }
      }
      rows.sort((a,b)=>a.ts - b.ts);
      return rows;
    }

    let syncTimer = null;
    async function syncToCloud(){
      if (!CLOUD_SYNC_ENABLED) return;
      clearTimeout(syncTimer);
      syncTimer = setTimeout(async ()=>{
        try{
          const { lastTs } = getLastSynced();
          const payload = collectPointsSince(lastTs);
          if (!payload.length) return;

          const r = await fetch(`${POLLUTION_API}/ingest`, {
            method: "POST",
            headers: { "Content-Type":"application/json" },
            body: JSON.stringify({ device: getDeviceId(), rows: payload })
          });
          if (!r.ok) throw new Error("ingest error");
          const newest = payload[payload.length - 1].ts;
          setLastSynced(newest);
        } catch(e){
          console.warn("Cloud sync failed:", e);
        }
      }, 800);
    }

    // ==========================
    // Cesium App â€” VARNA
    // ==========================
    async function startCesiumApp(){
      loadTsStore();

      const viewerOpts = { baseLayerPicker:true, timeline:false, animation:false, shadows:true };

      // Default camera rectangle over Varna
      Cesium.Camera.DEFAULT_VIEW_RECTANGLE = Cesium.Rectangle.fromDegrees(
        27.85, 43.17,   // west, south
        28.02, 43.27    // east, north
      );
      Cesium.Camera.DEFAULT_VIEW_FACTOR = 0.5;

      viewer = new Cesium.Viewer("cesiumContainer", viewerOpts);
      viewer.scene.globe.depthTestAgainstTerrain = true;
      viewer.scene.requestRenderMode = true;
      viewer.scene.maximumRenderTimeChange = 1/30;
      viewer.terrainProvider = await Cesium.createWorldTerrainAsync();
      viewer.scene.globe.enableLighting = true;

      // Load Varna buildings (rename your file to this)
      const buildingSelector = document.getElementById("buildingSelector");
      const dataSource = await Cesium.GeoJsonDataSource.load("varna_buildings_with_heights.geojson", { clampToGround:false });
      viewer.dataSources.add(dataSource);

      await viewer.zoomTo(
        dataSource,
        new Cesium.HeadingPitchRange(
          Cesium.Math.toRadians(180),
          Cesium.Math.toRadians(-40),
          2500
        )
      );

      buildings = dataSource.entities.values;

      buildings.forEach((building, i) => {
        const name = `Building ${i+1}`;
        building.name = name;
        const height = parseFloat(building.properties?.height?.getValue?.() ?? building.properties?.height) || 10;

        if (building.polygon) {
          building.polygon.extrudedHeight = height;
          building.polygon.height = 0;
          building.polygon.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
          building.polygon.extrudedHeightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
          building.polygon.material = Cesium.Color.LIGHTGRAY.withAlpha(1.0);
          building.polygon.outline = false;
        }

        const option = document.createElement("option");
        option.value = name; option.textContent = name;
        buildingSelector.appendChild(option);
      });

      if (CLOUD_SYNC_ENABLED) {
        await backfillHistory(7);
        saveTsStore();
      }

      initChartUI();

      await fetchUHIAndUpdate();
      setInterval(fetchUHIAndUpdate, 60_000);

      setInterval(()=>{ pruneOldData(); saveTsStore(); }, 5*60*1000);

      // Tooltip on hover (unchanged)
      const tooltip = document.getElementById("tooltip");
      viewer.screenSpaceEventHandler.setInputAction((movement) => {
        const picked = viewer.scene.pick(movement.endPosition);
        if (picked && picked.id && picked.id.properties) {
          const props = picked.id.properties;
          const usePred = document.getElementById("predictionToggle").checked;
          const tempVal = getEntityTemp(picked.id);
          const h = props?.height?.getValue?.() ?? props?.height ?? "N/A";
          const name = picked.id.name ?? "Unknown";
          const label = usePred ? "Pred" : "Temp";
          const tNum = Number(tempVal);
          tooltip.innerHTML = `<strong>${name}</strong><br>Height: ${h} m<br>${label}: ${isFinite(tNum)?tNum.toFixed(2):"N/A"} Â°C`;
          tooltip.style.left = (movement.endPosition.x + 15) + "px";
          tooltip.style.top  = (movement.endPosition.y + 15) + "px";
          tooltip.style.display = "block";
        } else {
          tooltip.style.display = "none";
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      // UI bindings (unchanged)
      document.getElementById("colorPicker").addEventListener("input", updateStyles);
      document.getElementById("buildingSelector").addEventListener("change", updateStyles);
      document.getElementById("heatToggle").addEventListener("change", updateStyles);
      document.getElementById("predictionToggle").addEventListener("change", updateStyles);
      document.getElementById("colorMode").addEventListener("change", updateStyles);
      document.getElementById("palette").addEventListener("change", updateStyles);
      document.getElementById("binCount").addEventListener("input", updateStyles);

      document.getElementById("shadowToggle").addEventListener("change", (e) => {
        const enabled = e.target.checked;
        viewer.shadows = enabled;
        viewer.scene.shadowMap.enabled = enabled;
        viewer.scene.requestRender();
      });

      // Time slider controls the Cesium clock
      const timeSlider = document.getElementById("timeSlider");
      const timeLabel  = document.getElementById("timeLabel");
      function setClockHour(h){
        timeSlider.value = h;
        timeLabel.textContent = `${h}:00`;
        const base = new Date(); base.setHours(h, 0, 0, 0);
        viewer.clock.currentTime = Cesium.JulianDate.fromDate(base);
        updateStyles();
      }
      timeSlider.addEventListener("input", ()=>setClockHour(parseInt(timeSlider.value)));
      document.querySelectorAll(".snapBtn").forEach(btn => {
        btn.addEventListener("click", ()=>{
          const mins = parseInt(btn.dataset.mins);
          const now = new Date(); const snap = new Date(now.getTime() + mins*60*1000);
          setClockHour(snap.getHours());
        });
      });

      // ====== Traffic Heatmap dots (static) â€” VARNA filenames ======
      function clearHeatmap(){
        for (const e of heatmapEntities) viewer.entities.remove(e);
        heatmapEntities.length = 0;
      }

      async function loadHeatmap(timeOfDay) {
        clearHeatmap();

        const dotsToggle = document.getElementById("heatmapDotsToggle");
        const shouldDraw = !!(dotsToggle && dotsToggle.checked);

        try {
          const file = `varna_${timeOfDay}_heatpoints.json`; // <-- renamed for Varna
          const response = await resilientFetch(file);
          const data = await response.json();

          if (shouldDraw) {
            const LIFT_M = 6.0;
            for (const [lat, lon, speed] of data) {
              const normalized = clamp01(speed / 60);
              const hue = (1 - normalized) * 240; // blueâ†’red
              const color = Cesium.Color.fromHsl(hue / 360, 1.0, 0.5).withAlpha(0.8);

              const entity = viewer.entities.add({
                position: Cesium.Cartesian3.fromDegrees(lon, lat, LIFT_M),
                point: {
                  pixelSize: 10,
                  color,
                  outlineColor: Cesium.Color.WHITE,
                  outlineWidth: 1,
                  heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
                  disableDepthTestDistance: Number.POSITIVE_INFINITY
                }
              });
              heatmapEntities.push(entity);
            }
          }
        } catch (e) {
          console.warn("Heatmap load failed", e);
        }
        viewer.scene.requestRender();
      }

      const heatmapTimeSelector = document.getElementById("heatmapTimeSelector");
      const heatmapDotsToggle   = document.getElementById("heatmapDotsToggle");

      heatmapTimeSelector.addEventListener("change", () => {
        loadHeatmap(heatmapTimeSelector.value);
      });

      heatmapDotsToggle.addEventListener("change", () => {
        if (heatmapDotsToggle.checked) {
          loadHeatmap(heatmapTimeSelector.value);
        } else {
          clearHeatmap();
        }
      });

      if (heatmapDotsToggle && heatmapDotsToggle.checked) {
        loadHeatmap(heatmapTimeSelector.value || "morning");
      } else {
        clearHeatmap();
      }

      // ====== Live Traffic (TomTom) ======
      const liveTrafficToggle = document.getElementById("liveTrafficToggle");
      const trafficRefresh = document.getElementById("trafficRefresh");
      const trafficStatus = document.createElement("div");
      Object.assign(trafficStatus.style, {
        position:"absolute", right:"1rem", top:"1rem", zIndex:20,
        background:"rgba(255,255,255,0.9)", padding:"6px 10px", borderRadius:"10px",
        fontFamily:"system-ui, sans-serif", fontSize:"12px", boxShadow:"0 2px 6px rgba(0,0,0,.15)"
      });
      trafficStatus.textContent = "Traffic: startingâ€¦";
      document.body.appendChild(trafficStatus);
      const setTrafficStatus = (msg)=>trafficStatus.textContent = `Traffic: ${msg}`;

      function addOrUpdateTrafficLayer(){
        const ts = Date.now();
        const provider = new Cesium.UrlTemplateImageryProvider({
          url: `https://api.tomtom.com/traffic/map/4/tile/flow/relative/{z}/{x}/{y}.png?key=${tomtomKey}&ts=${ts}`,
          maximumLevel: 20,
          tilingScheme: new Cesium.WebMercatorTilingScheme(),
          credit: "TomTom Traffic"
        });
        provider.errorEvent.addEventListener(()=> setTrafficStatus(`error`));
        const newLayer = viewer.imageryLayers.addImageryProvider(provider);
        newLayer.alpha = 0.7;

        if (trafficLayer) viewer.imageryLayers.remove(trafficLayer, false);
        trafficLayer = newLayer;

        const started = performance.now();
        (function waitReady(){
          if (provider.ready) {
            const dt = ((performance.now()-started)/1000).toFixed(1);
            setTrafficStatus(`updated @ ${new Date().toLocaleTimeString()} (+${dt}s)`);
            viewer.scene.requestRender();
          } else {
            requestAnimationFrame(waitReady);
          }
        })();
      }
      function beginTrafficUpdates(){
        addOrUpdateTrafficLayer();
        const everyMs = Math.max(15000, parseInt(trafficRefresh.value,10)*1000);
        if (trafficTimer) clearInterval(trafficTimer);
        trafficTimer = setInterval(addOrUpdateTrafficLayer, everyMs);
      }
      function stopTrafficUpdates(){
        if (trafficTimer) { clearInterval(trafficTimer); trafficTimer = null; }
        if (trafficLayer) { viewer.imageryLayers.remove(trafficLayer, false); trafficLayer = null; }
        setTrafficStatus("off");
        viewer.scene.requestRender();
      }
      liveTrafficToggle.addEventListener("change", (e)=> e.target.checked ? beginTrafficUpdates() : stopTrafficUpdates());
      trafficRefresh.addEventListener("change", ()=> { if (liveTrafficToggle.checked) beginTrafficUpdates(); });

      if (liveTrafficToggle && liveTrafficToggle.checked) {
        beginTrafficUpdates();
      } else {
        stopTrafficUpdates();
      }
    }

    // ======== ICT / Ops telemetry (unchanged) ========
    let ictChart = null;

    function bucketByHour(rows) {
      const map = new Map();
      for (const r of rows) {
        const d = new Date(Number(r.ts));
        d.setMinutes(0,0,0);
        const k = d.getTime();
        map.set(k, (map.get(k) || 0) + 1);
      }
      return [...map.entries()].sort((a,b)=>a[0]-b[0]).map(([t,c])=>({ t, c }));
    }

    async function timedFetch(url, init){
      const t0 = performance.now();
      const res = await fetch(url, init);
      const t1 = performance.now();
      return { res, ms: Math.max(0, Math.round(t1 - t0)) };
    }

    function ensureIctChart(){
      if (ictChart) return ictChart;
      const ctx = document.getElementById("ictChart").getContext("2d");
      ictChart = new Chart(ctx, {
        type: "bar",
        data: { labels: [], datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          interaction: { mode: "index", intersect: false },
          scales: {
            x: { type: "time", time: { unit: "hour" } },
            y: { title: { display:true, text:"updates/hour" }, beginAtZero:true, suggestedMax:8 },
            y1:{ title: { display:true, text:"latency (ms)" }, position:"right", beginAtZero:true, grid:{ drawOnChartArea:false } }
          },
          plugins: { legend: { display: true, position: "top" } },
          elements: { point: { radius: 0 }, line: { tension: 0.25 } }
        }
      });
      return ictChart;
    }

    async function refreshICT(){
      const stampEl  = document.getElementById("ictStamp");
      const upEl     = document.getElementById("ictUptime");
      const latestEl = document.getElementById("ictLatest");
      const latEl    = document.getElementById("ictLatency");

      const latestTimed = await timedFetch(`${POLLUTION_API}/latest`, { cache:"no-store" }).catch(()=>null);
      let latestJson = null, latencyMs = null;
      if (latestTimed && latestTimed.res.ok) {
        latestJson = await latestTimed.res.json();
        latencyMs = latestTimed.ms;
      }
      const histTimed = await timedFetch(`${POLLUTION_API}/history?days=1`, { cache:"no-store" }).catch(()=>null);
      let history = [];
      if (histTimed && histTimed.res.ok) {
        history = await histTimed.res.json();
        latencyMs = Math.max(latencyMs ?? 0, histTimed.ms);
      }

      const now = new Date();
      stampEl.textContent = `as of ${now.toLocaleTimeString()}`;

      const ts = Number(latestJson?.ts) || (history.length ? Number(history.at(-1).ts) : NaN);
      latestEl.textContent = Number.isFinite(ts) ? new Date(ts).toLocaleTimeString() : "â€”";

      const perHour = bucketByHour(history);
      const last24 = perHour.slice(-24);
      const actual = last24.reduce((s,p)=>s + Math.min(p.c, 6), 0);
      const expected = 24 * 6;
      const uptime = Math.round((actual/expected)*100);
      upEl.textContent = `${Math.max(0, Math.min(100, uptime))}%`;

      latEl.textContent = latencyMs != null ? `${latencyMs} ms` : "â€”";

      const chart = ensureIctChart();
      chart.data.labels = last24.map(p=>p.t);
      chart.data.datasets = [
        {
          type: "bar",
          label: "Updates/hour",
          data: last24.map(p=>({ x:p.t, y:p.c })),
          borderWidth: 0
        },
        {
          type: "line",
          label: "API latency (ms)",
          yAxisID: "y1",
          data: last24.map(p=>({ x:p.t, y: latencyMs || 0 })),
          borderWidth: 2,
          pointRadius: 0
        }
      ];
      chart.update();
    }

    refreshICT();
    setInterval(refreshICT, 60_000);

    // ==========================
    // Kickoff
    // ==========================
    startCesiumApp();

    // ==========================
    // Panels: drag + collapse + resize (unchanged)
    // ==========================
    (function enhancePanels(){
      const PANELS = [
        { id:'#controlPanel',        handle:'.drag-handle' },
        { id:'#uhiLegendRight',      handle:'.drag-handle' },
        { id:'#pollutionPanel',      handle:'.drag-handle' },
        { id:'#pollutionChartPanel', handle:'.drag-handle' },
        { id:'#ictPanel',            handle:'.drag-handle' },
      ];

      PANELS.forEach(cfg=>{
        const el = document.querySelector(cfg.id);
        if (!el) return;

        el.classList.add('panel');

        if (!el.querySelector('.panel-body')) {
          const handle = el.querySelector(cfg.handle) || el.firstElementChild;
          const body = document.createElement('div');
          body.className = 'panel-body';
          let n = handle ? handle.nextSibling : el.firstChild;
          while (n) {
            const next = n.nextSibling;
            if (!(n.classList && n.classList.contains('panel-tools'))) body.appendChild(n);
            n = next;
          }
          el.appendChild(body);
        }

        if (!el.querySelector('.panel-tools')) {
          const tools = document.createElement('div');
          tools.className = 'panel-tools';
          tools.innerHTML = `
            <div class="toolbtn" title="Collapse/Expand" data-act="toggle">âˆ’</div>
            <div class="toolbtn" title="Reset size" data-act="reset">â¤º</div>
          `;
          el.appendChild(tools);
          tools.addEventListener('click', (e)=>{
            const btn = e.target.closest('.toolbtn'); if (!btn) return;
            if (btn.dataset.act === 'toggle') el.classList.toggle('panel-collapsed');
            if (btn.dataset.act === 'reset') { el.style.width=''; el.style.height=''; }
          });
        }

        if (!el.querySelector('.resize-handle')) {
          const rh = document.createElement('div');
          rh.className = 'resize-handle';
          el.appendChild(rh);

          let resizing=false, startX=0, startY=0, startW=0, startH=0;
          const onDown = (ev)=>{
            resizing = true;
            const p = ev.touches ? ev.touches[0] : ev;
            startX = p.clientX; startY = p.clientY;
            const r = el.getBoundingClientRect();
            startW = r.width; startH = r.height;
            ev.preventDefault();
          };
          const onMove = (ev)=>{
            if (!resizing) return;
            const p = ev.touches ? ev.touches[0] : ev;
            const dw = p.clientX - startX;
            const dh = p.clientY - startY;
            el.style.width  = Math.max(260, startW + dw) + 'px';
            el.style.height = Math.max(120, startH + dh) + 'px';
            ev.preventDefault();
          };
          const onUp = ()=>{ resizing=false; };
          rh.addEventListener('mousedown', onDown);
          rh.addEventListener('touchstart', onDown, { passive:false });
          window.addEventListener('mousemove', onMove);
          window.addEventListener('touchmove', onMove, { passive:false });
          window.addEventListener('mouseup', onUp);
          window.addEventListener('touchend', onUp);
        }

        const grip = el.querySelector(cfg.handle);
        if (!grip) return;

        el.style.position = 'absolute';
        const state = { x:0, y:0, left:0, top:0, dragging:false };

        const clampToViewport = (left, top, w, h)=>{
          const pad = 8;
          const maxL = window.innerWidth  - w - pad;
          const maxT = window.innerHeight - h - pad;
          return [ Math.max(pad, Math.min(left, maxL)), Math.max(pad, Math.min(top,  maxT)) ];
        };

        const onDown = (e)=>{
          if (e.target.closest('input,select,textarea,button,label,.resize-handle,.panel-tools')) return;

          const rect = el.getBoundingClientRect();
          const scrollX = window.scrollX || 0;
          const scrollY = window.scrollY || 0;

          el.classList.remove('-translate-x-1/2', 'left-1/2');

          if (!el.style.left) el.style.left = (rect.left + scrollX) + 'px';
          if (!el.style.top)  el.style.top  = (rect.top  + scrollY) + 'px';

          state.x = (e.touches ? e.touches[0].clientX : e.clientX);
          state.y = (e.touches ? e.touches[0].clientY : e.clientY);
          state.left = parseFloat(el.style.left) || rect.left + scrollX;
          state.top  = parseFloat(el.style.top)  || rect.top  + scrollY;
          state.dragging = true;

          el.dataset.prevZ = el.style.zIndex || '';
          el.style.zIndex = '10000';
          el.classList.add('dragging');

          window.addEventListener('mousemove', onMove);
          window.addEventListener('touchmove', onMove, { passive:false });
          window.addEventListener('mouseup', onUp, { once:true });
          window.addEventListener('touchend', onUp, { once:true });
          e.preventDefault();
        };

        const onMove = (e)=>{
          if (!state.dragging) return;
          const cx = (e.touches ? e.touches[0].clientX : e.clientX);
          const cy = (e.touches ? e.touches[0].clientY : e.clientY);
          const dx = cx - state.x;
          const dy = cy - state.y;

          const rect = el.getBoundingClientRect();
          let nextLeft = state.left + dx;
          let nextTop  = state.top  + dy;
          [nextLeft, nextTop] = clampToViewport(nextLeft, nextTop, rect.width, rect.height);

          el.style.left = nextLeft + 'px';
          el.style.top  = nextTop  + 'px';
          el.style.right = '';
          el.style.bottom = '';
          e.preventDefault();
        };

        const onUp = ()=>{
          state.dragging = false;
          el.classList.remove('dragging');
          if (el.dataset.prevZ !== undefined) el.style.zIndex = el.dataset.prevZ;
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('touchmove', onMove);
        };

        grip.addEventListener('mousedown', onDown);
        grip.addEventListener('touchstart', onDown, { passive:false });
      });
    })();

    // === Place UHI legend once, positioned relative to the Varna panel ===
    (function placeLegendOnce(){
      const GAP = 12;
      const PAD = 8;

      function rect(el){
        const r = el.getBoundingClientRect();
        return { left:r.left + window.scrollX, top:r.top + window.scrollY, width:r.width, height:r.height };
      }
      function clamp(left, top, w, h){
        const minL = window.scrollX + PAD;
        const minT = window.scrollY + PAD;
        const maxL = window.scrollX + window.innerWidth  - w - PAD;
        const maxT = window.scrollY + window.innerHeight - h - PAD;
        return [ Math.max(minL, Math.min(left, maxL)), Math.max(minT, Math.min(top, maxT)) ];
      }
      function setLT(el, left, top){
        el.style.left = Math.round(left) + "px";
        el.style.top  = Math.round(top)  + "px";
        el.style.right = "";
        el.style.bottom = "";
      }

      window.addEventListener("load", ()=>{
        const control = document.getElementById("controlPanel");
        const legend  = document.getElementById("uhiLegendRight");
        if (!control || !legend) return;

        legend.classList.remove("hidden");
        legend.style.right = ""; legend.style.bottom = "";

        requestAnimationFrame(()=>{
          const ar = rect(control);
          const br = rect(legend);

          let left = ar.left - br.width - GAP;
          let top  = ar.top;

          if (left < window.scrollX + PAD) {
            left = ar.left + ar.width + GAP;
          }

          const [L, T] = clamp(left, top, br.width, br.height);
          setLT(legend, L, T);
        });
      });
    })();
  </script>
</body>
</html>
